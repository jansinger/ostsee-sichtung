name: PR Validation

on:
  pull_request:
    branches: [ main, next, beta, alpha ]
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate:
    name: Validate Pull Request
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Setup environment
        run: cp .env.example .env
        
      - name: Install dependencies
        run: npm ci
        
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
        
      - name: Validate commit messages
        run: |
          echo "Validating commit messages from origin/main to HEAD..."
          npx commitlint --from=origin/main --to=HEAD --verbose
          
      - name: Run linting
        run: npm run lint
        
      - name: Run type checking
        run: npm run type-check
        
      - name: Run unit tests
        run: npm run test:unit -- --run
        
      - name: Run E2E tests
        run: npm run test:e2e
        
      - name: Run Svelte check
        run: npm run check
        
      - name: Build application
        run: npm run build
        
      - name: Check for conventional commit format
        id: check-commits
        uses: actions/github-script@v7
        with:
          script: |
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            const conventionalCommitRegex = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .{1,50}/;
            
            let hasInvalidCommits = false;
            let invalidCommits = [];
            
            for (const commit of commits) {
              const message = commit.commit.message.split('\n')[0]; // First line only
              if (!conventionalCommitRegex.test(message)) {
                hasInvalidCommits = true;
                invalidCommits.push({
                  sha: commit.sha.substring(0, 7),
                  message: message
                });
              }
            }
            
            if (hasInvalidCommits) {
              let comment = `❌ **Conventional Commits Validation Failed**\n\n`;
              comment += `The following commits do not follow the [Conventional Commits](https://www.conventionalcommits.org/) specification:\n\n`;
              
              for (const commit of invalidCommits) {
                comment += `- \`${commit.sha}\`: ${commit.message}\n`;
              }
              
              comment += `\n**Required format:** \`type(scope): description\`\n\n`;
              comment += `**Valid types:** feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert\n\n`;
              comment += `**Examples:**\n`;
              comment += `- \`feat(auth): add OAuth login support\`\n`;
              comment += `- \`fix(api): handle null response in export endpoint\`\n`;
              comment += `- \`docs: update README with setup instructions\`\n\n`;
              comment += `Please update your commit messages and force push the changes.`;
              
              // Create or update comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('Conventional Commits Validation')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: comment
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              }
              
              core.setFailed(`Found ${invalidCommits.length} commits that don't follow Conventional Commits format`);
            } else {
              // Delete any existing validation failure comments
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('Conventional Commits Validation Failed')
              );
              
              if (botComment) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id
                });
              }
              
              // Add success comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '✅ **All commits follow Conventional Commits specification!**\n\nThis PR is ready for review.'
              });
            }
            
      - name: Label PR based on changes
        uses: actions/github-script@v7
        with:
          script: |
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            let labels = [];
            let hasBreakingChanges = false;
            
            for (const commit of commits) {
              const message = commit.commit.message;
              
              // Check for breaking changes
              if (message.includes('BREAKING CHANGE') || message.includes('!:')) {
                hasBreakingChanges = true;
                labels.push('breaking-change');
              }
              
              // Determine type
              const match = message.match(/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)/);
              if (match) {
                const type = match[1];
                switch (type) {
                  case 'feat':
                    labels.push('feature');
                    break;
                  case 'fix':
                    labels.push('bugfix');
                    break;
                  case 'docs':
                    labels.push('documentation');
                    break;
                  case 'refactor':
                    labels.push('refactor');
                    break;
                  case 'perf':
                    labels.push('performance');
                    break;
                  case 'test':
                    labels.push('test');
                    break;
                  case 'build':
                  case 'ci':
                    labels.push('build');
                    break;
                  case 'chore':
                    labels.push('maintenance');
                    break;
                }
              }
            }
            
            // Remove duplicates
            labels = [...new Set(labels)];
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labels
              });
            }