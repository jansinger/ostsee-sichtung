name: PR Validation

on:
  pull_request:
    branches: [main, next, beta, alpha]
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate:
    name: Validate Pull Request
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup environment
        run: cp .env.example .env

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright Browsers
        run: npx playwright install --with-deps

      - name: Ensure Svelte Kit is in sync
        run: npx svelte-kit sync

      - name: Validate commit messages
        run: |
          echo "Validating commit messages from origin/main to HEAD..."
          npx commitlint --from=origin/main --to=HEAD --verbose

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run unit tests
        run: npm run test:unit -- --run

      - name: Run Svelte check
        run: npm run check

      - name: Build application
        run: npm run build

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Check for conventional commit format
        id: check-commits
        uses: actions/github-script@v7
        with:
          script: |
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            const conventionalCommitRegex = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .{1,50}/;

            let hasInvalidCommits = false;
            let invalidCommits = [];

            for (const commit of commits) {
              const message = commit.commit.message.split('\n')[0]; // First line only
              if (!conventionalCommitRegex.test(message)) {
                hasInvalidCommits = true;
                invalidCommits.push({
                  sha: commit.sha.substring(0, 7),
                  message: message
                });
              }
            }

            if (hasInvalidCommits) {
              let comment = `❌ **Conventional Commits Validation Failed**\n\n`;
              comment += `The following commits do not follow the [Conventional Commits](https://www.conventionalcommits.org/) specification:\n\n`;
              
              for (const commit of invalidCommits) {
                comment += `- \`${commit.sha}\`: ${commit.message}\n`;
              }
              
              comment += `\n**Required format:** \`type(scope): description\`\n\n`;
              comment += `**Valid types:** feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert\n\n`;
              comment += `**Examples:**\n`;
              comment += `- \`feat(auth): add OAuth login support\`\n`;
              comment += `- \`fix(api): handle null response in export endpoint\`\n`;
              comment += `- \`docs: update README with setup instructions\`\n\n`;
              comment += `Please update your commit messages and force push the changes.`;
              
              // Create or update comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('Conventional Commits Validation')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: comment
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              }
              
              core.setFailed(`Found ${invalidCommits.length} commits that don't follow Conventional Commits format`);
            } else {
              // Delete any existing validation failure comments
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('Conventional Commits Validation Failed')
              );
              
              if (botComment) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id
                });
              }
              
              // Add success comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '✅ **All commits follow Conventional Commits specification!**\n\nThis PR is ready for review.'
              });
            }

      - name: Label PR based on changes
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: commits } = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
              });
              
              // Get existing labels in the repository
              const { data: repoLabels } = await github.rest.issues.listLabelsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              
              const existingLabelNames = repoLabels.map(label => label.name);
              
              let labels = [];
              let hasBreakingChanges = false;
              
              for (const commit of commits) {
                const message = commit.commit.message;
                
                // Check for breaking changes
                if (message.includes('BREAKING CHANGE') || message.includes('!:')) {
                  hasBreakingChanges = true;
                  if (existingLabelNames.includes('breaking-change')) {
                    labels.push('breaking-change');
                  }
                }
                
                // Determine type
                const match = message.match(/^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)/);
                if (match) {
                  const type = match[1];
                  let labelName = '';
                  
                  switch (type) {
                    case 'feat':
                      labelName = 'feature';
                      break;
                    case 'fix':
                      labelName = 'bugfix';
                      break;
                    case 'docs':
                      labelName = 'documentation';
                      break;
                    case 'refactor':
                      labelName = 'refactor';
                      break;
                    case 'perf':
                      labelName = 'performance';
                      break;
                    case 'test':
                      labelName = 'test';
                      break;
                    case 'build':
                    case 'ci':
                      labelName = 'build';
                      break;
                    case 'chore':
                      labelName = 'maintenance';
                      break;
                  }
                  
                  // Only add label if it exists in the repository
                  if (labelName && existingLabelNames.includes(labelName)) {
                    labels.push(labelName);
                  }
                }
              }
              
              // Remove duplicates
              labels = [...new Set(labels)];
              
              if (labels.length > 0) {
                console.log(`Adding labels: ${labels.join(', ')}`);
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labels
                });
              } else {
                console.log('No matching labels found in repository');
              }
            } catch (error) {
              console.log(`Failed to add labels: ${error.message}`);
              // Don't fail the workflow if labeling fails
            }
